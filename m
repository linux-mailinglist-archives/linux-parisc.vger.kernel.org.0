Return-Path: <linux-parisc-owner@vger.kernel.org>
X-Original-To: lists+linux-parisc@lfdr.de
Delivered-To: lists+linux-parisc@lfdr.de
Received: from vger.kernel.org (vger.kernel.org [23.128.96.18])
	by mail.lfdr.de (Postfix) with ESMTP id 8A29722538B
	for <lists+linux-parisc@lfdr.de>; Sun, 19 Jul 2020 20:41:18 +0200 (CEST)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1726024AbgGSSlR (ORCPT <rfc822;lists+linux-parisc@lfdr.de>);
        Sun, 19 Jul 2020 14:41:17 -0400
Received: from belmont79srvr.owm.bell.net ([184.150.200.79]:50723 "EHLO
        mtlfep01.bell.net" rhost-flags-OK-OK-OK-FAIL) by vger.kernel.org
        with ESMTP id S1726009AbgGSSlR (ORCPT
        <rfc822;linux-parisc@vger.kernel.org>);
        Sun, 19 Jul 2020 14:41:17 -0400
Received: from bell.net mtlfep01 184.150.200.30 by mtlfep01.bell.net
          with ESMTP
          id <20200719184116.QVDF5779.mtlfep01.bell.net@mtlspm02.bell.net>
          for <linux-parisc@vger.kernel.org>;
          Sun, 19 Jul 2020 14:41:16 -0400
Received: from [192.168.2.49] (really [70.53.53.104]) by mtlspm02.bell.net
          with ESMTP
          id <20200719184116.HDGP16482.mtlspm02.bell.net@[192.168.2.49]>;
          Sun, 19 Jul 2020 14:41:16 -0400
To:     linux-parisc <linux-parisc@vger.kernel.org>
Cc:     Helge Deller <deller@gmx.de>,
        James Bottomley <James.Bottomley@HansenPartnership.com>
From:   John David Anglin <dave.anglin@bell.net>
Subject: [PATCH] parisc: Various spin lock optimizations
Message-ID: <048514e6-5f68-acfa-dd1e-25d4b2d09897@bell.net>
Date:   Sun, 19 Jul 2020 14:41:16 -0400
User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:68.0) Gecko/20100101
 Thunderbird/68.10.0
MIME-Version: 1.0
Content-Type: text/plain; charset=utf-8
Content-Language: en-US
Content-Transfer-Encoding: 7bit
X-CM-Analysis: v=2.3 cv=E9SzWpVl c=1 sm=1 tr=0 a=htCe9XT+XAlGhzqgweArVg==:117 a=htCe9XT+XAlGhzqgweArVg==:17 a=IkcTkHD0fZMA:10 a=_RQrkK6FrEwA:10 a=FBHGMhGWAAAA:8 a=qzxedKmj14NH_mNJ6awA:9 a=30ykUda5FDYTlvdn:21 a=is4syvXs-LcVHCcR:21 a=QEXdDO2ut3YA:10 a=9gvnlMMaQFpL9xblJ6ne:22
X-CM-Envelope: MS4wfCCgf4lmQ/mXKii7k8oFevXkWRs5bh0aSz8MOILTYq767iQKNj1Ks6oeSxbKj/fT7bqnaGrPB3fGGIzCaYpw5p7LrED23FbaFUtIiZfIW0HodZBhD3J4 s2ebhFUEkjLrarW3rgYmgS+7TO9sQ3YwCoUgdSCSCIKpmf9tl31O50E87zPLzSSHbjifRUmDrYmrSw==
Sender: linux-parisc-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-parisc.vger.kernel.org>
X-Mailing-List: linux-parisc@vger.kernel.org

While investigating the stall problem, I looked closely at our spin lock implementation and found
a number of minor issues.

Regarding arch_spin_is_locked(), I wasn't convinced that the barrier was correct, so I switched the
code to use READ_ONCE.

Regarding arch_spin_lock(), cpu_relax() slightly pessimizes the loop code generated by gcc.  The pointer
"a" is volatile, so we can just use continue.

Regarding arch_spin_lock_flags(), I went back to the old code which just toggles interrupts on and off
in the wait loop.  It's rather dangerous to allow the routine to set all the PSW flag bits and wierd
things happen if local_save_flags() is moved.

Regarding arch_spin_unlock(), I defined a new barrier __ldcw_mb().  It optimizes to a nop when a SMP
kernel is used on a non SMP machine.

Finally regarding arch_spin_trylock(), I just shortened the C code.

Signed-off-by: Dave Anglin <dave.anglin@bell.net>
---

diff --git a/arch/parisc/include/asm/ldcw.h b/arch/parisc/include/asm/ldcw.h
index e080143e79a3..0b182450a2fb 100644
--- a/arch/parisc/include/asm/ldcw.h
+++ b/arch/parisc/include/asm/ldcw.h
@@ -51,6 +51,19 @@
 	__ret;							\
 })

+/* LDCW is strongly ordered and can be used as a memory barrier
+   when a suitably aligned address is available. */
+#ifdef CONFIG_SMP
+#define __ldcw_mb(a) ({						\
+	unsigned __tmp;						\
+	__asm__ __volatile__(__LDCW " 0(%1),%0"			\
+	ALTERNATIVE(ALT_COND_NO_SMP, INSN_NOP)			\
+	: "=r" (__tmp) : "r" (a) : "memory");			\
+})
+#else
+#define __ldcw_mb(a) barrier();
+#endif
+
 #ifdef CONFIG_SMP
 # define __lock_aligned __section(.data..lock_aligned)
 #endif
diff --git a/arch/parisc/include/asm/spinlock.h b/arch/parisc/include/asm/spinlock.h
index 70fecb8dc4e2..dd13753e20de 100644
--- a/arch/parisc/include/asm/spinlock.h
+++ b/arch/parisc/include/asm/spinlock.h
@@ -10,8 +10,7 @@
 static inline int arch_spin_is_locked(arch_spinlock_t *x)
 {
 	volatile unsigned int *a = __ldcw_align(x);
-	smp_mb();
-	return *a == 0;
+	return READ_ONCE(*a) == 0;
 }

 static inline void arch_spin_lock(arch_spinlock_t *x)
@@ -21,22 +20,21 @@ static inline void arch_spin_lock(arch_spinlock_t *x)
 	a = __ldcw_align(x);
 	while (__ldcw(a) == 0)
 		while (*a == 0)
-			cpu_relax();
+			continue;
 }

 static inline void arch_spin_lock_flags(arch_spinlock_t *x,
-					 unsigned long flags)
+					  unsigned long flags)
 {
 	volatile unsigned int *a;
-	unsigned long flags_dis;

 	a = __ldcw_align(x);
 	while (__ldcw(a) == 0) {
-		local_save_flags(flags_dis);
-		local_irq_restore(flags);
 		while (*a == 0)
-			cpu_relax();
-		local_irq_restore(flags_dis);
+			if (flags & PSW_SM_I) {
+				local_irq_enable();
+				local_irq_disable();
+			}
 	}
 }
 #define arch_spin_lock_flags arch_spin_lock_flags
@@ -46,23 +44,16 @@ static inline void arch_spin_unlock(arch_spinlock_t *x)
 	volatile unsigned int *a;

 	a = __ldcw_align(x);
-#ifdef CONFIG_SMP
-	(void) __ldcw(a);
-#else
-	mb();
-#endif
+	__ldcw_mb(a);
 	*a = 1;
 }

 static inline int arch_spin_trylock(arch_spinlock_t *x)
 {
 	volatile unsigned int *a;
-	int ret;

 	a = __ldcw_align(x);
-        ret = __ldcw(a) != 0;
-
-	return ret;
+	return __ldcw(a) != 0;
 }

 /*
